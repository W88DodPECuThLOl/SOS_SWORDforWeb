<!doctype html>
<html>
	<head>
		<meta charset=”UTF-8″>
		<title>S-OS"SWORD"</title>
		<script src="./js/sos/SOSWorkAddr.js"></script>
		<script src="./js/sos/SOSErrorCode.js"></script>
		<script src="./js/sos/SOSInfomationBlock.js"></script>
		<script src="./js/sos/SOS.js"></script>
		<script src="./js/sos/taskLineInput.js"></script>
		<script src="./js/sos/taskPlatformMonitor.js"></script>
		<script src="./js/sos/taskContext.js"></script>
		<script src="./js/z80Emu.js"></script>
		<script src="./js/taskMonitor.js"></script>
		<script src="./js/cat/catAudio.js"></script>
		<link rel="stylesheet" href="./css/catVolume.css">
		<link rel="stylesheet" href="./css/catTextScreen.css">
		<link rel="stylesheet" href="./css/sosLogo.css">
		<link rel="stylesheet" href="./css/catMediaIcon.css">
		<link rel="stylesheet" href="./css/catSystemIcon.css">
		<style>
			@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@700&display=swap');
		</style>
	</head>
	<body>
		<div>
			<div id="fs-target">
				<div id="fs-inner" class="canvas-wrapper">
					<canvas id="graphicCanvas" class="graphicsLayer"></canvas>
					<div id="sos_output" class="console"></div>
				</div>
			</div>
			<div class="cat-bar">
				<div class="cat-bar-inner">
					<div id="cat-bar-media" class="cat-bar-media">
						<ul>
							<li><div id="drive0" class="cat-media-icon-fd"></div>
								<ul>
									<li><div class="media-menu-item-header">Drive A</div></li>
									<li>
										<div id="mnt0">Insert disk image</div>
										<input type="file" id="disk0" accept=".d88,.2D,.obj" style="display:none;"/>
									</li>
									<li><div id="blankdisk0">Insert blank image</div></li>
									<li><div id="save0" class="media-menu-item-disable">Save disk image</div></li>
									<li><div id="unmnt0" class="media-menu-item-disable">Remove disk image</div></li>
								</ul>
							</li>
							<li><div id="drive1" class="cat-media-icon-fd"></div>
								<ul>
									<li><div class="media-menu-item-header">Drive B</div></li>
									<li>
										<div id="mnt1">Insert disk image</div>
										<input type="file" id="disk1" accept=".d88,.2D,.obj" style="display:none;"/>
									</li>
									<li><div id="blankdisk1">Insert blank image</div></li>
									<li><div id="save1" class="media-menu-item-disable">Save disk image</div></li>
									<li><div id="unmnt1" class="media-menu-item-disable">Remove disk image</div></li>
								</ul>
							</li>
							<li><div id="drive2" class="cat-media-icon-fd"></div>
								<ul>
									<li><div class="media-menu-item-header">Drive C</div></li>
									<li>
										<div id="mnt2">Insert disk image</div>
										<input type="file" id="disk2" accept=".d88,.2D,.obj" style="display:none;"/>
									</li>
									<li><div id="blankdisk2">Insert blank image</div></li>
									<li><div id="save2" class="media-menu-item-disable">Save disk image</div></li>
									<li><div id="unmnt2" class="media-menu-item-disable">Remove disk image</div></li>
								</ul>
							</li>
							<li><div id="drive3" class="cat-media-icon-fd"></div>
								<ul>
									<li><div class="media-menu-item-header">Drive D</div></li>
									<li>
										<div id="mnt3">Insert disk image</div>
										<input type="file" id="disk3" accept=".d88,.2D,.obj" style="display:none;"/>
									</li>
									<li><div id="blankdisk3">Insert blank image</div></li>
									<li><div id="save3" class="media-menu-item-disable">Save disk image</div></li>
									<li><div id="unmnt3" class="media-menu-item-disable">Remove disk image</div></li>
								</ul>
							</li>
							<li><div id="drive4" class="cat-media-icon-ram-disk"></div>
								<ul>
									<li><div class="media-menu-item-header">Drive E(RAM DISK)</div></li>
									<li><div id="save4" class="media-menu-item-disable">Save disk image</div></li>
								</ul>
							</li>
							<!--
							<li><div class="cat-media-icon-tape"></div>
								<ul>
									<li><div class="media-menu-item-header">Drive T(Tape)</div></li>
									<li><div>Insert tape image</div></li>
									<li><div class="media-menu-item-disable">Remove tape image</div></li>
								</ul>
							</li>
							-->
						</ul>
					</div>
					<div class="sos-logo">
						<span>S-OS“SWORD”</span>
					</div>
					<div id="cat-bar-system" class="cat-bar-system">
						<!-- ボリューム -->
						<div class="cat-volume-setting">
							<div id="cat-volume-off" class="cat-volume-off-icon"></div>
							<div id="cat-volume" class="cat-volume-icon"></div>
							<input id="cat-volume-bar" type="range" value="0" min="0" max="100" data-unit="%"/>
						</div>
						<!-- フルスクリーン切り替え -->
						<div id="full-screen" class="cat-media-icon-full-screen"></div>
						<!--
						<div class="cat-system-icon-setting"></div>
						<div class="cat-system-icon-game-pad"></div>
						-->
					<div>
				</div>
			</div>
		</div>






		<script type="module">
			"use strict";
			// D88
			import Context from './js/HuBasic/HuBasic/Context.mjs';
			import HuBasicDisk from './js/HuBasic/HuBasic/HuBasicDisk.mjs';
			// SOS
			import CatKey from './js/cat/catKey.js';
			import CatTextScreen from './js/cat/catTextScreen.js';
			import CatGamePad from './js/cat/catGamePad.js';
			import CatFullScreen from './js/cat/catFullScreen.js';
			
			// フルスクリーン制御
			new CatFullScreen(document, "fs-target", "full-screen", evt => {
					// フルスクリーンの設定
					const screenWidth = window.parent.screen.width;
					const screenHeight = window.parent.screen.height;
					const elem = document.getElementById("fs-inner")
					elem.style.transform = "scale(" + screenWidth / 640 + "," + screenHeight / 400 + ")";
				},
				evt => {
					// フルスクリーン抜けたときの設定
					const elem = document.getElementById("fs-inner")
					elem.style.transform = "scale(" + 1 + "," + 1 + ")";
				}
			);

			// サウンド制御
			var soundMute = true;
			var soundMasterVolume = 0.5;
			{
				const volumeCtrl = document.getElementById("cat-volume");
				const volumeBar = document.getElementById("cat-volume-bar");
				volumeBar.value = soundMasterVolume * 100;

				volumeCtrl.addEventListener("click", ()=>{
					soundMute = !soundMute;
					if(soundMute) {
						volumeCtrl.style.backgroundImage = 'url(./img/icon/ボリュームOFFアイコン.png)';
					} else {
						volumeCtrl.style.backgroundImage = 'url(./img/icon/ボリュームアイコン3.png)';
					}
				});
				volumeBar.addEventListener("change", ()=>{
					soundMute = false;
					if(soundMute) {
						volumeCtrl.style.backgroundImage = 'url(./img/icon/ボリュームOFFアイコン.png)';
					} else {
						volumeCtrl.style.backgroundImage = 'url(./img/icon/ボリュームアイコン3.png)';
					}
					soundMasterVolume = volumeBar.value / 100;
					//console.log(soundMasterVolume);
				});
			}

			// グラフィック
			const graphicCanvas = document.getElementById("graphicCanvas");
			graphicCanvas.setAttribute("width", 640);
			graphicCanvas.setAttribute("height", 200);
			var graphicCanvasCtx = graphicCanvas.getContext("2d");
			// ディスクドライブ
			var disks = [];
			for(let i = 0; i < 5; ++i) {
				var ctxDisk = new Context();
				if(i != 2 && i != 3) {
					ctxDisk.Setting.SetImageType("2D"); // メモ)S-OSは2Dのみ対応
					ctxDisk.Setting.FormatImage = true; // マウント時にフォーマットするように設定
				}
				ctxDisk.onDriveStateChange = (isMount, isAccess) => { updateDriveInfo(i, isMount, isAccess); };
				disks.push(new HuBasicDisk(ctxDisk));

				const diskSave = document.getElementById('save' + i);
				diskSave.addEventListener('click', evt => {
					const diskImage = disks[i].SaveDisk(false);
					const blob = new Blob([diskImage], {type: 'application/octet-stream'}); // Blob オブジェクトの作成
					const link = document.createElement('a');
					link.download = 'disk' + String.fromCodePoint(0x41 + i) + '.d88'; // ダウンロードファイル名称
					link.href = window.URL.createObjectURL(blob); // オブジェクト URL を生成
					link.click(); // クリックイベントを発生させる
					window.URL.revokeObjectURL(link.href); // オブジェクト URL を解放」
				});
			}

			var audio = new CatAudio();
			var gamePad = new CatGamePad(navigator);
			var z80Emu = new Z80Emu(audio, gamePad);
			var taskLineInput = new TaskLineInput();
			var taskMonitor = new TaskMonitor();
			var taskPlatformMonitor = new TaskPlatformMonitor();
			var catKey = new CatKey(document);
			var catTextScreen = new CatTextScreen(80,25);

			// URL Param
			// ?fnt=PC8001でPC8001風のフォントマップに
			// ?exec=実行したいファイルのURL
			const queryString = window.location.search;
			const urlParams = new URLSearchParams(queryString);
			const fontSet = urlParams.get('fnt'); // 起動時に使用するフォント名
			const execFile = urlParams.get('exec'); // 起動時に使用するイメージファイル名
			const mountDisk1 = urlParams.get('mnt1'); // B
			const mountDisk2 = urlParams.get('mnt2'); // C
			const mountDisk3 = urlParams.get('mnt3'); // D
			var beepvol = urlParams.get('beepvol') ? parseFloat(urlParams.get('beepvol')) : 0.2; // BEEP音の音量
			const beepfile = urlParams.get('beepfile') ? urlParams.get('beepfile') : './wav/X1BEEP.WAV'; // BEEP音で使用する音声ファイル名
			const GamePadConfig = parseGamePadConfig(queryString); // ゲームパッドの設定

			// BELL(BEEP)音
			var sound = new Audio(beepfile); // BEEPで再生する音声ファイル
			var catSnd = {
				/**
				 * ビープ音を再生する
				 */
				bell: ()=> {
					if(beepvol > 0.0) {
						if(!soundMute) {
							sound.currentTime = 0; // 連続再生するときのおまじないらしい
							sound.volume = beepvol * soundMasterVolume; // 音量
							sound.play();
						}
					}
				}
			}

			// デフォルトのフォントを読み込む
			{
				const fontFace = new FontFace('defaultFont', 'url(./fonts/3/SMILEBASIC.ttf)');
				fontFace.load().then(function(loadedFace){
					// フォント読み込み成功
					document.fonts.add(loadedFace);
				}).catch(function(e){
					// フォント読み込み失敗
					console.error('フォントの読み込みに失敗しました');
				});
			}

			var ctx = new TaskContext(z80Emu, catKey, catTextScreen, taskLineInput, taskMonitor, taskPlatformMonitor, disks, catSnd, gamePad);
			// 初期のフォント設定
			if(fontSet) {
				ctx.changeFont(fontSet); // URLパラメータで設定されたフォント
			} else {
				ctx.changeFont("SOS"); // デフォルトのフォント
			}

			function diskSetup()
			{
				for(let i = 0; i < 4; i++) {
					const disk = document.getElementById('disk' + i);
					// マウント
					const mnt = document.getElementById('mnt' + i);
					mnt.addEventListener('click', evt => {
						disk.value = '';
						disk.click();
					});
					disk.addEventListener('change', evt => {
						let input = evt.target;
						if (input.files.length == 0) {
							disks[i].unmount();
							return;
						}
						const file = input.files[0];
						const reader = new FileReader();
						reader.onload = () => {
							const readData = new Uint8Array(reader.result);
							mountImage(i, file.name, readData);
						};
						reader.readAsArrayBuffer(file);
					});
					// アンマウント
					const unmnt = document.getElementById('unmnt' + i);
					unmnt.addEventListener('click', evt => {
						disks[i].unmount();
						disk.value = '';
					});
					// 空きディスク
					const blankDisk = document.getElementById('blankdisk' + i);
					blankDisk.addEventListener('click', evt => {
						const ctxDisk = new Context();
						ctxDisk.Setting.SetImageType("2D"); // メモ)S-OSは2Dのみ対応
						ctxDisk.Setting.FormatImage = true; // マウント時にフォーマットするように設定
						ctxDisk.onDriveStateChange = (isMount, isAccess) => { updateDriveInfo(i, isMount, isAccess); };
						disks[i] = new HuBasicDisk(ctxDisk);
						disk.value = '';
					});
				}
			}

			/**
			 * ドライブの状態を更新する
			 */
			function updateDriveInfo(driveNo, isMount, isAccess)
			{
				let baseClass = driveNo <= 3 ? "cat-media-icon-fd" : "cat-media-icon-ram-disk";
				const drive = document.getElementById('drive' + driveNo);
				const saveMenuItem = document.getElementById('save' + driveNo);
				const unmountMenuItem = document.getElementById('unmnt' + driveNo);
				if(isMount) {
					if(isAccess) {
						// ドライブアクセス
						//
						// アニメ再生
						// メモ）１回リセットして次のフレームで、再生させる
						//      そうしないと、再生されない
						drive.className = baseClass + "-mnt";
						window.requestAnimationFrame(function(time) {
							window.requestAnimationFrame(function(time) {
								drive.className = baseClass + "-mnt-acc";
							});
						});
					} else {
						// マウント状態
						drive.className = baseClass + "-mnt";
					}
					// メニュー項目
					if(unmountMenuItem) {
						unmountMenuItem.className = "";
					}
					if(saveMenuItem) {
						saveMenuItem.className = "";
					}
				} else {
					// アンマウント状態
					drive.className = baseClass;
					// メニュー項目
					if(unmountMenuItem) {
						unmountMenuItem.className = "media-menu-item-disable";
					}
					if(saveMenuItem) {
						saveMenuItem.className = "media-menu-item-disable";
					}
				}
			}

			/**
			 * ディスクイメージをマウント、または、１個のファイルを実行する
			 * @param {number} deviceNo デバイス(0～3)
			 * @param filename
			 * @param {Uint8Array} readData イメージデータ
			 */
			function mountImage(deviceNo, filename, readData)
			{
				if(isSOSFileHeader(readData)) {
					// SOSのファイルヘッダあり
					const loadAddress = (ctx.hex(readData[0x8]) << 12) | (ctx.hex(readData[0x9]) << 8) | (ctx.hex(readData[0xA]) << 4) | ctx.hex(readData[0x0B]);
					const execAddress = (ctx.hex(readData[0xD]) << 12) | (ctx.hex(readData[0xE]) << 8) | (ctx.hex(readData[0xF]) << 4) | ctx.hex(readData[0x10]);
					const attribute   = (ctx.hex(readData[0x5]) <<  4) |  ctx.hex(readData[0x6]);
					if((attribute & 7) == 0x01) {
						// バイナリファイル
						ctx.memoryWrite(readData.subarray(18), loadAddress); // 読み込んで
						ctx.execCommand(execAddress); // 実行
					} else {
						// アスキーファイル
						alert("未対応の属性(FileMode)です。")
						return false;
					}
				} else if(isD88Image(readData)) {
					// D88のイメージ
					// ディスクをセットする
					disks[deviceNo].mount(filename, readData, false);
				} else if(is2dImage(filename, readData)) {
					// 2Dの生イメージ
					// ディスクをセットする
					disks[deviceNo].mount(filename, readData, true);
				} else {
					alert("不明なフォーマットタイプです。")
					return false;
				}
				return true;
			}

			function isSOSFileHeader(data)
			{
				// ファイルサイズで、判定
				if(data.length <= 18) { return false; }
				// ヘッダ部分で判定
				if(data[0x00] != 0x5F || data[0x01] != 0x53 || data[0x02] != 0x4F || data[0x03] != 0x53 || data[0x04] != 0x20) {
					return false;
				}
				// その他判定出来そうな所で
				if(data[0x07] != 0x20 || data[0x0C] != 0x20 || data[0x11] != 0x0A) {
					return false;
				}
				// 多分S-OSのヘッダ付きのファイル
				return true;
			}

			function is2dImage(filename, data)
			{
				// 2Dフォーマット時の標準的なファイルサイズで、判定
				if(data.length != 327680) { return false; }
				// イメージファイル名が2Dではないので違う
				if(!filename.endsWith(".2D") && !filename.endsWith(".2d")) { return false; }
				// OK
				return true;
			}
			function isD88Image(data)
			{
				// D88の2Dフォーマット時の標準的なファイルサイズで、判定
				if(data.length < 348848) { return false; }
				// リザーブエリアが0かどうかで判定
				for(let i = 0x11; i < 0x1A; ++i) {
					if(data[i] != 0x00) { return false; }
				}
				// プロテクトの設定が正しいかどうか
				if(data[0x1A] != 0x00 && data[0x1A] != 0x10) {
					return false;
				}
				// データサイズで判定
				const size = data[0x1C] | (data[0x1D] << 8) | (data[0x1E] << 16) | (data[0x1F] << 24);
				if(size != data.length) {
					return false;
				}
				// このぐらいでゆるしておく
				return true;
			}

			// ゲームパッドの設定
			function parseGamePadConfig(queryString)
			{
				const urlParams = new URLSearchParams(queryString);
				let cfg = {
					/**
					 * ゲームパッドをキーに割り当てるかどうか
					 */
					KeyAssign: urlParams.get('padKeyAssign') ? urlParams.get('padKeyAssign') : false,

					/**
					 * テンキー（数字）に左アナログスティックを割り当てるかどうか
					 * 
					 * 0: 割り当てない
					 * 1: 左アナログスティックを割り当てる
					 */
					AssignNumPad: urlParams.get('padAssignNumPad') ? urlParams.get('padAssignNumPad') : 0,

					/**
					 * ボタン類のキーマッピング
					 */
					ButtonMap: []
				};
				// 定型
				if(urlParams.get('padMap') == "boya") {
					cfg.KeyAssign = true;
					cfg.AssignNumPad = 1;
					cfg.ButtonMap = [
						{ GamePadButtonIndex: [gamePad.BUTTON_A_INDEX],  KeyCode: 0x20 },  // spc
						{ GamePadButtonIndex: [gamePad.BUTTON_LT_INDEX], KeyCode: 0x0d },  // CR
						{ GamePadButtonIndex: [gamePad.BUTTON_B_INDEX, gamePad.BUTTON_Y_INDEX],  KeyCode: 0x5a },  // Z
						{ GamePadButtonIndex: [gamePad.BUTTON_X_INDEX, gamePad.BUTTON_LB_INDEX],  KeyCode: 0x58 },  // X
						{ GamePadButtonIndex: [gamePad.BUTTON_RB_INDEX, gamePad.BUTTON_RT_INDEX], KeyCode: 0x43 },  // C
					];
				}
				// URLパラメータからボタンを割り当てる
				// 例）padKey20=0     Aボタン(0)をキーコード0x20(スペース)に割り当てる
				// 例）padKeyD=1      Bボタン(1)をキーコード0x0D(エンター)に割り当てる
				// ボタンの値
				//   0: A
				//   1: B
				//   2: X
				//   3: Y
				//   4: LB
				//   5: RB
				//   6: LT
				//   7: RT
				//   8: BACK
				//   9: START
				//  10: L3
				//  11: R3
				//  12: デジタルの方向キーの上
				//  13: デジタルの方向キーの下
				//  14: デジタルの方向キーの左
				//  15: デジタルの方向キーの右
				//  16: HOME
				//　仮想ボタン
				//  28: 左アナログスティックとデジタルを合わせたもの 右
				//  29: 左アナログスティックとデジタルを合わせたもの 左
				//  30: 左アナログスティックとデジタルを合わせたもの 上
				//  31: 左アナログスティックとデジタルを合わせたもの 下
				for(let keyCode = 0; keyCode < 0x100; ++keyCode) {
					const name = 'padKey' + keyCode.toString(16).toUpperCase();
					if(urlParams.has(name)) {
						let k = keyCode;
						switch(keyCode) {
							case 0x1C: k = "ArrowRight"; break;
							case 0x1D: k = "ArrowLeft"; break;
							case 0x1E: k = "ArrowUp"; break;
							case 0x1F: k = "ArrowDown"; break;
						}
						cfg.ButtonMap.push({ GamePadButtonIndex: [urlParams.get(name)], KeyCode: k } );
						// １個でも設定されていたらゲームパッドのキー割り当てを有効にしておく
						cfg.KeyAssign = true;
					}
				}
				return cfg;
			}

			function gamePadToKey(gamePadConfig)
			{
				if(!gamePadConfig.KeyAssign) {
					return; // ゲームパッドのキーボード割り当て無効
				}
				// ボタン
				let release = false ;
				for(let m of gamePadConfig.ButtonMap) {
					// 押した、離した
					let pressed = false;
					let released = false;
					for(let idx of m.GamePadButtonIndex) {
						const btn = gamePad.buttons[idx];
						pressed  = pressed  || btn.pressed;
						released = released || btn.released;
					}
					// キーとして反映させる
					if (pressed) {
						catKey.enqueueKeyBuffer(m.KeyCode) ;
					} else if (released) {
						catKey.keyUp(m.KeyCode) ;
						release = true ;
					}
				}
				// 方向
				if(gamePadConfig.AssignNumPad == 1) {
					// テンキー（数字）に反映させる
					// メモ）ボタン類が離されたときに、方向が入っていたら方向が押されたように。
					// 　　　移動中に、ボタンおしたときに、移動が中断されにくくなるので。
					for (let k = 1; k <= 9; ++k) {
						const btn = gamePad.buttons[gamePad.BUTTON_VDIR_NUM0 + k];
						if (btn.current) {
							if (btn.pressed || release == true) {
								catKey.enqueueKeyBuffer(0x30 + k) ;
							}
						} else {
							if (btn.released) {
								catKey.keyUp(0x30 + k) ;
							}
						}
					}
				}
			}

			function update()
			{
				// ゲームパッドの更新
				gamePad.update();
				// ゲームパッドのキー割り当て処理
				gamePadToKey(GamePadConfig);
				// Z80えみゅ
				z80Emu.update(ctx);
				// ライン入力
				taskLineInput.update(ctx);
				// モニタ
				taskMonitor.update(ctx);
				taskPlatformMonitor.update(ctx);
				// テキスト描画
				if(catTextScreen.isModified()) {
					document.getElementById("sos_output").innerHTML = catTextScreen.draw();
				}
				// グラフィック描画
				z80Emu.getVRAMImage(graphicCanvasCtx);
				// VSync待ち
				requestAnimationFrame(()=>update());
			}

			function autoStart() {
				const execFileReader = new XMLHttpRequest() ;
				//execFileReader.open("get", "./files/" + execFile, true) ;
				execFileReader.open("get", execFile, true) ;
				execFileReader.responseType = "arraybuffer" ;
				
				execFileReader.onerror = () => {
					alert("読み込み中にエラーが発生しました:" + execFile + "\nstatus:" + execFileReader.status);
				};
				execFileReader.onload = (evnt) => {
					if(execFileReader.status >= 400) {
						alert("読み込み中にエラーが発生しました:" + execFile + "\nstatus:" + execFileReader.status);
						return;
					}
					const objArray = execFileReader.response ;
					const objFile  = new Uint8Array(objArray) ;
					mountImage(0, execFile, objFile);
				}
				execFileReader.send() ;
			}
			
			// ページ読み込み後に実行される
			window.onload = async function() {
				// サウンド
				let psgBin = await (await fetch('./psg.wasm')).arrayBuffer();
				const soundOn = document.getElementById("cat-volume-off");
				const volume = document.getElementById("cat-volume");
				const volumeBar = document.getElementById("cat-volume-bar");
				soundOn.addEventListener("click", ()=>{
					// サウンドの初期化
					audio.init(psgBin);
					// 多重初期化できないように消しちゃう
					soundMute = false;
					soundOn.style.display = 'none';
					volume.style.display = 'inline';
					volumeBar.style.display = 'inline';
				});

				// Z80エミュのセットアップ
				z80Emu.setup().then(
					(emu)=> {
						// ディスク
						diskSetup();
						// SOS
						ctx.reset();
						// auto staart
						if(execFile != null) {
							autoStart() ;
						}
						// 開始
						update();
					}
				);
			}
		</script>
	</body>
</html>